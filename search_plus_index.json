{"./":{"url":"./","title":"前言","keywords":"","body":"Java NIO 学习笔记 NIO（New IO）是 JDK1 1.4 之后引入的特性，它在标准的 Java 代码中提供了高速的面向块的 IO。 "},"基础.html":{"url":"基础.html","title":"基础","keywords":"","body":"NIO 前言 参考资料 前言 Java NIO 主要包含三个重要的概念： 缓冲区 Buffer 通道 Channel 选择器 Selector 我们依次来看下相关的知识。 参考资料 Java NIO Tutorial Java NIO 系列教程 Java NIO 学习笔记 Java NIO入门与详解 NIO 入门 Java NIO Tutorial "},"Buffer.html":{"url":"Buffer.html","title":"Buffer","keywords":"","body":"缓冲区 属性 初始化 写入数据 读取数据 释放缓冲区 标记 类别 缓冲区本质上就是一块内存，可以向该内存中写入数据以及从内存中读取数据。这块内存被包装成 NIO Buffer 对象，并提供了相关的 API，以方便的访问这块内存。需要注意的是缓冲区在读模式和写模式下有不同的行为。 属性 缓冲区通过四个属性来描述它所包含的数据信息： capacity（容量） 缓冲区能被容纳元素的最大数量。当缓冲区被创建之后，它的容量就已经确定了，在使用过程中不可改变 position（位置） 表示下一个要被读或者写的元素的索引。position 的最大有效值为 capacity-1。 limit（上界） 当缓冲区处于写模式时，limit 表示最多能往 Buffer 里写入的数据。该模式下，limit 就等于 Buffer 的 capacity。 当缓冲区处于读模式时，limit 表示最多可以读到的数据。在该模式下，limit 会被设置为写模式下的 positoin 值。 mark（标记） 保存一个 position 信息备份。通过调用 mark() 方法，可以将 mark 值设为当前 position 值，即 mark=position。随后再调用 reset 方法时，会将 position 值重置为 mark 值。初始时 mark 是未定义的，只有调用了 mark() 方法之后，mark 值才被定义。 初始化 Buffer 的子类有很多，这里我们以 ByteBuffer 为例，来看下缓冲区处于不同模式下的结构变化。下图是缓冲区刚被创建时的状态，此时缓冲区处于写模式。这里 mark 被设为 -1，用来表示 mark 是未定义的 （undefined）。我们看到缓冲区实际上就是一个数组加上我们前面说的几个属性，注意这里创建了一个长度为 10 的缓存区，索引从 0 - 9，10 元素是不存在，这里为了方便描述，绘制了一个虚拟的 10 号元素。 图片参考 Java NIO 写入数据 我们有两种方式向 Buffer 里写数据： 从 Channel 里写到 Buffer int bytesRead = inChannel.read(buf); //read into buffer. 通过 Buffer 的 put 方法 buf.put('A'); 假设我们向缓冲区中写入了 5 个元素，那么此时缓冲区就变为下面的状态： 在向缓冲区写入的过程中，会首先数据写入到 position 对应的位置，然后对 position 执行加 1 操作，下面是代码实现： final int nextPutIndex() { // package-private if (position >= limit) throw new BufferOverflowException(); return position++; } 读取数据 下面我们再来看下缓冲区的读操作。通过 flip 方法，可以将缓冲区切换到读取模式，我们看下 flip 方法的实现： public final Buffer flip() { limit = position; position = 0; mark = -1; return this; } 我们看到 flip 方法中其实做了3件事： 将 limit 设为 position：在读模式下，limit 主要用来标记缓冲区中可读元素的上限，也就是在读之前，缓冲区中已经写入的元素数量。根据缓冲区写入的过程，缓冲区中已经写入的元素个数其实就是写模式下的 position 值，所以这里将 limit 设为 position。 将 position 设为 0：因为缓冲区是顺序写入，所以我们从 0 开始都即可。 重置 mark。 下面是执行 flip 方法之后缓冲区的状态： 然后我们可以通过下面两种方式从缓冲区中读数据： 将 Buffer 数据读入到 Channel 中int bytesWritten = inChannel.write(buf); 调用 Buffer 的 get 方法，get 方法有多个版本，具体的参见 JDK 文档。byte aByte = buf.get(); 如果我们希望重新读数据，可以调用 rewind 方法，该方法会将 position 置为 0，而 limit 保持不变，下面是该方法的实现： public final Buffer rewind() { position = 0; mark = -1; return this; } 在读取完 position 位置的数据之后，也会将 position 的值加 1。另外从上面的图我们也可以看出，不管是读模式和写模式，Buffer 的 capatity 值是一致的。 释放缓冲区 当读完缓冲区的数据之后，需要让 buffer 准备好再次被写入，也就是将缓冲区中的数据释放掉。我们可以通过 clear() 或者 compact() 方法来清除数据。我们首先看下 clear 方法，下面是实现代码： public final Buffer clear() { position = 0; limit = capacity; mark = -1; return this; } 我们看到 clear 方法只是重置了 position、limit 和 mark 这 3 个变量，Buffer 中原有的数据并没有被清除。 在看 compact 方法之前，我们首先看下 hasRemaining 和 remaining 方法： hasRemaining - 查询是否还有剩余元素 写模式 - 检查缓冲区中是否还有空闲的空间可以写入， 读模式 - 检查缓冲区中是否还有未读的元素public final boolean hasRemaining() { return position remaining - 返回剩余元素的个数 写模式 - 返回空闲元素的个数 读模式 - 返回未读元素的个数public final int remaining() { return limit - position; } compact 方法会保留未读数据。该方法首先将所有未读的元素拷贝到 Buffer 起始处，然后将 position 指向最后一个未读元素的后面，下图是一个示例。下图中我们假设缓冲区已经被读了两个元素，然后对该缓冲区调用 compact 方法。 下面我们看下 ByteBuffer 中 compact 方法的实现： public ByteBuffer compact() { // 复制 Buffer 剩余元素到 Buffer 起始处 System.arraycopy(hb, ix(position()), hb, ix(0), remaining()); // 设置 position为剩余元素个数值 position(remaining()); // 设置 limit 值为 capacity limit(capacity()); // 重置 mark discardMark(); return this; } /** * @param src the source array. * @param srcPos starting position in the source array. * @param dest the destination array. * @param destPos starting position in the destination data. * @param length the number of array elements to be copied. */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 标记 下面我们来看下 mark 属性。mark 属性主要用来设置一个标记，然后我们可以将 position 重置到 mark 标记的位置。通过调用 mark() 方法会将 mark 的值设为当前的 position 值，当调用 reset() 方法时，会将 position 重置为 mark 值，如果 mark 未定义，会抛出 InvalidMarkException 异常。注意我们前面说的 rewind()、clear()、flip() 方法会重置 mark 值，下面是两个方法的实现： public final Buffer mark() { mark = position; return this; } public final Buffer reset() { int m = mark; if (m 类别 NIO 中提供了不同的 Buffer 用来存储不同的数据类型，主要包含下面几种： CharBuffer ShortBuffer IntBuffer LongBuffer FloatBuffer DoubleBuffer ByteBuffer 下面是相关的数据类型以及大小 数据类型 大小(字节数量) char 2 short 2 int 4 long 8 float 4 double 8 byte 1 其中 ByteBuffer 比较特殊，它以字节为单位，可以通过 asXXXBuffer 方法转换成其他类型的 Buffer，例如转换为 CharBuffer：byteBuffer.asCharBuffer()。需要注意的一点是转换成 CharBuffer 时会有编码问题，这个在后面讨论。 "},"Channel.html":{"url":"Channel.html","title":"Channel","keywords":"","body":"通道 FileChannel 打开 从 FileChannel中读取数据 向 FileChannel 中写入数据 关闭 FileChannel position size truncate force 文件锁定 Zero Copy Socket Channel ServerSocketChannel SocketChannel DatagramChannel 通道（Channel） 提供与 IO 服务的直接连接，使用 Channel 我们可以在字节缓冲区和通道另一侧的实体（通常是一个文件或者套接字）之间有效的传输数据。Channel 主要分为两类：File Channel（文件通道）和 Socket Channel（套接字通道） FileChannel FileChannel 主要用来处理文件，FileChannel 总是运行在阻塞模式下，无法将其设置为非阻塞模式。FileChannel 是线程安全的，多个进程可以在同一个实例上并发调用相关方法，不过对于影响 Channel 位置（position）或者文件大小的操作都进行同步处理。 打开 FileChannel 不能直接创建，而是要创建一个文件对象（RandomAccessFile、FileInputStream、FileOutputStream），然后再调用 getChannel 方法获得。 RandomAccessFile randomAccessFile = new RandomAccessFile(filePath, \"rw\"); FileChannel fileChannel = randomAccessFile.getChannel(); RandomAccessFile 打开文件的模式有下面四种 \"r\" - 只读 \"rw\" - 可读写文件，如果文件不存在，则创建文件 \"rws\" - 可读写文件，并且文件数据以及元数据的每个更新都会写入磁盘 \"rwd\" - 可读写文件，并且文件数据的每个更新操作都会写入到磁盘 RandomAccessFile 对象采用 lazy-load 的方式创建 FileChannel，创建完之后会将 FileChannel 缓存起来，并进行了同步处理，下面是相关代码： public final FileChannel getChannel() { synchronized(this) { if (channel == null) { channel = FileChannelImpl.open(fd, path, true, rw, this); } return channel; } } 从 FileChannel中读取数据 通过 read 方法可以从 FileChannel 中将数据读到 Buffer 中，read 方法会返回一个 int 值表示有多少个字节被读到了 Buffer 中，如果返回 -1，说明到了文件末尾。从 Channel 读取数据的过程中会针对 Channel 进行同步处理。 ByteBuffer byteBuffer = ByteBuffer.allocate(64); int byteRead = fileChannel.read(byteBuffer); 下面是 FileChannel中 几个相关的 read 方法： // 读取数据到缓冲区 public abstract int read(ByteBuffer dst) throws IOException; // 从指定的 position 处开始读取数据 public abstract int read(ByteBuffer dst, long position) throws IOException; // 以 scatter 方式读取文件，即将文件内容读取到多个缓冲区 // offset 指定从哪个缓冲区开始写入，length 表示使用的缓冲区数量 public long read(ByteBuffer[] dsts, int offset, int length) throws IOException; // 以 scatter 方式读取文件 public final long read(ByteBuffer[] dsts) throws IOException { return read(dsts, 0, dsts.length); } 向 FileChannel 中写入数据 使用 write 方法，我们可以向 FileChannel 中写入数据，在写入的时候也会针对当前 Channel 进行同步处理。 String newData = \"data\"; ByteBuffer byteBuffer = ByteBuffer.allocate(48); byteBuffer.clear(); byteBuffer.put(newData.getBytes()); byteBuffer.flip(); while (byteBuffer.hasRemaining()) { channel.wirte(byteBuffer); } write 方法也有四种形式，含义和读取的时候类似 // 将 Buffer 的数据写入 FileChannel public abstract int write(ByteBuffer src) throws IOException; // 将 Buffer 的数据写入 FileChannel，从 position 处开始写入 public abstract int write(ByteBuffer src, long position) throws IOException; // 将多个 Buffer 的数据写入 FileChannel，gather 形式 public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException; // 将多个 Buffer 的数据写入 FileChannel public final long write(ByteBuffer[] srcs) throws IOException { return write(srcs, 0, srcs.length); } 关闭 FileChannel 使用完 FileChannel 之后需要调用 close 方法将其关闭 channel.close(); 下面是 close 方法的实现： public final void close() throws IOException { synchronized(closeLock) { if (!open) return; open = false; implCloseChannel(); } } position 有时候我们需要在 FileChannel 的某个特定位置进行读写操作，我们可以通过 position 方法获取和设置 FileChannel 的当前位置 // 获得 FileChannel 当前的位置 long pos = channel.position(); // 设置 FileChannel 的当前位置 channel.position(pos + 123); 假设我们将位置设置在文件结束符之后，再次对 FileChannel 读写，会出现下面的结果： 调用 read 方法读取数据，会直接放回 -1，也就是文件结束标志 调用 write 方法写数据，文件将撑大到当前位置并写入数据。这有可能导致 文件空洞 size size 方法将返回 FileChannel 关联文件的大小： long fileSize = channel.size(); truncate 使用 truncate 方法可以截取一个文件。截取文件时，文件中指定长度后面的部分将被删除： channel.truncate(1024); 上面的例子将会截取文件的前 1024 个字节。 force FileChannel 中的 force 方法会将 Channel 中没有写入磁盘的数据强制写到磁盘中。出于性能方面的考虑，操作系统会将数据缓存到内存中，所以无法保证写入到 FileChannel 中的数据一定会即时的写到磁盘中，如果我们需要保证这一点，就要调用 force 方法。force 方法有一个 boolean 类型的参数，指明是否同时将文件元数据（权限信息等）写入到磁盘中。 channel.force(true); 文件锁定 通过 FileChannel 的 lock 和 tryLock 方法，我们可以对文件进行加锁。注意这里的文件锁是与具体的文件进行关联的，而不是 Channel 关联。文件锁主要是针对外部进程，也就说如果文件锁被一个进程获得，那么其他进程就无法再次访问该文件，但是获得锁进程内部的线程还是共享文件的。下面是 FileChannel 与锁相关的几个函数： // 从 position 位置开始，锁定 size 长度的内容，shared 表示锁是否是共享的 // 如果要获取共享锁，要以只读权限打开文件，如果想要获取独占锁，则需要写权限 // 如果获取不到锁，进程就会处于阻塞状态。 public abstract FileLock lock(long position, long size, boolean shared) throws IOException; public final FileLock lock() throws IOException { return lock(0 L, Long.MAX_VALUE, false); } // 如果获取不到锁，会直接返回 null public abstract FileLock tryLock(long position, long size, boolean shared) throws IOException; public final FileLock tryLock() throws IOException { return tryLock(0 L, Long.MAX_VALUE, false); } 下面是 FileLock 的几个方法： // 查询创建该锁的 FileChannel 对象 public final FileChannel channel() // 释放锁 public abstract void release() throws IOException; // 返回文件被锁住的起始位置 public final long position() { return position; } // 返回文件被锁住的大小 public final long size() { return size; } // 判断是否是共享锁 public final boolean isShared() { return shared; } // 判断锁是否有效 public abstract boolean isValid(); // 主要用于 try 代码块中自动关闭资源 public final void close() throws IOException { release(); } Zero Copy 通过零拷贝实现有效数据传输 Socket Channel Socket 通道主要处理网络数据流，主要有下面 3 个类： ServerSocketChannel - 服务器套接字通道，用于 TCP 协议，监听传入的连接以及创建新的 SocketChannel 对象。ServerSocketChannel 本身不传输数据。 SocketChannel - 套接字通道，用于 TCP 协议。当客户端连接到服务器之后，服务器和客户端都会有一个 SocketChannel，两者通过 SocketChannel 进行通信。 DatagramChannel - 数据报通道，用于 UDP 协议。 Socket 通道可以以非阻塞模式运行，极大的提高了程序的性能，下面是相关方法： // block=false：非阻塞模式；block=true：阻塞模式 public abstract SelectableChannel configureBlocking(boolean block) throws IOException; // 查询当前通道是否处于阻塞模式 public abstract boolean isBlocking(); ServerSocketChannel ServerSocketChannel 是一个基于通道的 socket 监听器，它主要用来监听传入的请求，并为该请求创建一个关联的 SocketChannel 对象，服务器和客户端最终还是通过 SocketChannel 对象进行传输数据的。 // 创建 ServerSocketChannel 对象，只能同静态的 open 方法创建 ServerSocketChannel serverSocketChannel = ServerSocketChannel.open(); // 绑定监听地址，ServerSocketChannel 对象本身无法设置监听地址， // 需要通过其关联的 ServerSocket 对象来设置 serverSocketChannel.socket().bind(new InetSocketAddress(port)); // 设为非阻塞模式 serverSocketChannel.configureBlocking(false); while (true) { // accept 用来监听新的连接，因为是非阻塞模式，没有链接会返回 null SocketChannel socketChannel = serverSocketChannel.accept(); } SocketChannel 我们通过 SocketChannel 来传输数据，每个 SocketChannel 对象都会关联一个 Socket 对象，我们有两种方式获得 SocketChannel 调用 SocketChannel 的 open 方法 当一个新连接到达 ServerSocketChannel 时，会创建一个 SocketChannel 通过 open 方法获得 SocketChannel 对象需要连接之后才能使用，如果对个未连接的 SocketChannel 对象执行 IO 操作，会抛出 NotYetConnectedException，下面是一个使用示例： String host = \"localhost\"; int port = 1234; InetSocketAddress address = new InetSocketAddress(host, port); // 创建 SocketChannel 对象 SocketChannel socketChannel = SocketChannel.open(); // 设为非阻塞模式 socketChannel.configureBlocking(false); // 链接服务器 socketChannel.connect(address); // 判断是否已经建立连接 while (!socketChannel.finishConnect()) { // 在建立连接的过程中可以做一些其他的操作 System.out.println(\"do other things...\"); } ByteBuffer buffer = ByteBuffer.allocate(100); int readLen; // 这里采用了非阻塞模式，因此 read 方法可能会直接返回 0， // 即没有读到内容。但是只有读到 -1 时，才表明 socket 中 // 的数据已经读取完毕 while ((readLen = socketChannel.read(buffer)) != -1) { if (readLen != 0) { String result = new String(buffer.array()).trim(); System.out.println(result); } } // 关闭 socketChannel socketChannel.close(); Socket 是面向流（stream-oriented）的，而不是面向包（packet-oriented）的，它只能保证发送的字节会按照顺序到达，但是无法保证同时维持字节分组，假设向 socket 中传入了 20 个字节，那么调用 read 方法有可能只能读到 3 个字节，而剩余的 17 个字节还在传输中。 下面是 SokcetChannel 中的一些方法： // 判断是否完成连接过程 public abstract boolean finishConnect() throws IOException; // 判断是否建立了连接 public abstract boolean isConnected(); // 判断当前 Channel 是否正在建立连接 public abstract boolean isConnectionPending(); // 从 Channel 读取数据到 Buffer public abstract int read(ByteBuffer dst) throws IOException; // 从 Channel 读取数据到 多个 Buffer public abstract long read(ByteBuffer[] dsts, int offset, int length) throws IOException; public final long read(ByteBuffer[] dsts) throws IOException { return read(dsts, 0, dsts.length); } // 将 Buffer 中的数据写入到 Channel public abstract int write(ByteBuffer src) throws IOException; // 将多个 Buffer 中的数据写入到 Channel public abstract long write(ByteBuffer[] srcs, int offset, int length) throws IOException; public final long write(ByteBuffer[] srcs) throws IOException { return write(srcs, 0, srcs.length); } DatagramChannel DatagramChannel 主要通过 UDP 传输数据。UDP 是无连接的网络协议，所以 DatagramChannel 发送和接收的都是数据包，每个数据包都是一个独立的实体，包含自己的目标地址。DatagramChannel 对象既可以充当服务器，也可以充当客户端，如果希望 DatagramChannel 作为服务端，需要首先为其绑定一个地址。下面是一个示例： Server // 创建 DatagramChannel DatagramChannel datagramChannel = DatagramChannel.open(); // 绑定地址监听，作为服务端 datagramChannel.socket().bind(new InetSocketAddress(1111)); ByteBuffer buffer = ByteBuffer.allocate(64); while (true) { // 接受客户端发送过来的数据，如果数据的长度大于 // Buffer 的空间，那么多余的数据会被丢弃 // receive 方法会返回一个 SocketAddress 对象以指明数据来源 datagramChannel.receive(buffer); buffer.flip(); while (buffer.hasRemaining()) { System.out.write(buffer.get()); } System.out.println(); buffer.clear(); } Client List textList = new ArrayList ( Arrays.asList(\"1111\", \"2222\", \"3333\", \"4444\") ); InetAddress hostIP = InetAddress.getLocalHost(); InetSocketAddress address = new InetSocketAddress(hostIP, 1111); // 创建 DatagramChannel DatagramChannel datagramChannel = DatagramChannel.open(); datagramChannel.bind(null); ByteBuffer buffer = ByteBuffer.allocate(64); for (String text: textList) { System.out.println(\"sending msg: \" + text); buffer.put(text.getBytes()); buffer.flip(); // 发送数据时要指定目标地址 datagramChannel.send(buffer, address); buffer.clear(); } 在阻塞模式下，receive 方法可能无限期的休眠直到有数据包到达，而处于非阻塞模式下时，当没有可接收的数据包时会返回 null。 通过调用 connect 方法，可以连接一个 DatagramChannel，这里的连接只是绑定了一个 DatagramChannel，实际上并没有建立连接。当两个 DatagramChannel 处于连接状态时，它们只能相互通信。使用 disconnect 方法可以断开连接。 下面是使用数据报的情形： Your application can tolerate lost or out-of-order data. You want to fire and forget and don't need to know if the packets you sent were received. Throughput is more important than reliability. You need to send to multiple receivers (multicast or broadcast) simultaneously. The packet metaphor fits the task at hand better than the stream metaphor. "},"Selector.html":{"url":"Selector.html","title":"Selector","keywords":"","body":"Selector "}}